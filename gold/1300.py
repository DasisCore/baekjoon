# 1300. K번째 수

# 문제
# 세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.
# 배열 A와 B의 인덱스는 1부터 시작한다.
#
# 입력
# 첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.
#
# 출력
# B[k]를 출력한다.

############################################################################################

def check(x):
    total = 0
    # 행렬에서 x보다 작거나 같은 수의 개수.
    for i in range(1, n + 1):
        # x보다 i가 크면 곤란하므로, min을 이용해
        # 많아도 n개를 넘기지 않도록 한다.
        total += min(n, x // i)

    # 만약 x보다 작거나 같은 수의 개수가 k보다 크거나
    # 같아야 정답이 될 수 있다.
    return total >= k


n = int(input())
k = int(input())

s = 1
e = n * n

while s <= e:
    mid = (s + e) // 2

    # 정답이 될 수 있으면, 그중 가장 작은것을
    # 정답으로 뽑는다.
    if check(mid):
        ans = mid
        e = mid - 1
    else:
        s = mid + 1

print(ans)